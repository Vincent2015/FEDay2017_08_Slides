<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>第三届FEDay分享：谈项目中如何选择框架和库</title>
  <link rel="stylesheet" href="./dist/index.css">
</head>
<body>

  <template layout="cover" type="text/x-markdown">
  # 谈项目中如何选择<br>框架和库
  <div class="author">克军 / <a href="http://weibo.com/kejunz" target="_blank">@kejunz</a></div>

  -----

    今天我想谈的是在项目中如何选择框架和库。而不是我想学习一个框架和库，应该如何选择。这是两件目的非常不同的事，一个是“打仗”，一个是“演习”。后者纠结会少很多，对于学什么的问题？我建议放下顾虑，想学什么就学什么吧。广泛涉猎，肯定对个人能力的养成大有益处。尤其对前端工程师来说，跨界的见识，不仅有好处而且必要。

    做公司项目就不能太任性了。公司项目首先是公司的资产、是团队共同维护的项目、是一种契约项目。所以，应该避免由个人兴趣和偏好主导的技术方案的制订（除非符合后面提到的那些原则）。在做选择时，允许出于学（练）习（手）的目的。但无论怎样，都要考虑三件事：

  </template>

  <template layout="bullets" type="text/x-markdown">
  ## 前提：成本和效率

  - 实现目标的成本和效率
  - 团队协作的成本和效率
  - 后续迭代的成本和效率

  -----

    一是考虑实现产品目标的成本和效率。不能说我要先学几个月再动手做。或者，挖了一个大坑，刻意不用别人的“轮子”，最后影响产品提交的时间和品质

    这里引出一个问题：我们总觉得什么功能都用现成的库实现，是新手行为。是不是非要自己造轮子，才符合老司机的身份？（我个人认为设计代码比编写代码有意义，我看重两点：一是通过架构控制整个项目的复杂度和后续迭代的效率，二是最终产品完成的品质（设计还原的程度、可感知的效能和稳定性））

    二是考虑团队协作的成本和效率。过于小众的，或在团队内部有分歧的技术，你用了之后，没人愿意接盘的不能用，至少要说服大多数人愿意用

    三是考虑后续迭代的成本和效率。如这个方案能有效提高可维护性，能适应产品需求的变化，长效价值就高，一次性投入的成本就是必要的

    这是最基本的成本和效率原则。

  </template>


  <template layout="bullets" type="text/x-markdown">
  ![](./pics/f1.jpg)

  -----

    这张图说明：自己造轮子也好，用别人的轮子也好。首先，它要能切实的解决问题。如果能将整个团队的生产力提高一个层次，再时间紧任务急也要换上。我反对一些务虚的创造，中看不中用，不能有效解决问题的工具逼格再高，顶多也就是一个小众工具，价值有限。

    做开源项目也是，实战证明真的能有效解决开发痛点的项目再开源出去，才真正有价值。

  </template>


  <template class="slide-dimension" layout="bullets" type="text/x-markdown">
  ## 经常谈到...

  - 模式
  - 普及率
  - 成熟度
  - 体量
  - 局限性
  - 学习成本
  - 性能
  - 活跃性
  - 周边资源
  - 前景
  - 契合度
  - 文档质量

  -----

    谈到关于如何选择框架和库，我经常看到的是各种维度的比较。

    架构模式的比较，MVC / MVVM / 组件化的优缺点。体量是轻是重。执行效率如何。发展前景如何，是不是面向未来的技术，是否能持续流行下去。有多少公司(尤其是大公司)在使用。功能全不全，有哪些做不到。是否有人在一直维护。里面有没有什么坑，API是不是稳定。好不好学。有没有丰富的插件。文档是否友好…等等等等

    这些维度没问题。问题是在于，首先要以项目对技术的需求为出发点，而不是以工具为出发点。做选择时，这些维度的权重会随着要解决的问题不同而变化。不能是程咬金的“三板斧”。我们都听过小马过河的故事，在选择面前，我们要有自己的分析和判断的思路，而不是道听途说，盲目追逐潮流，或者。

  </template>


  <template layout="bullets" type="text/x-markdown">
  ## 选择的原则

   1. 妥适性原则
   1. 库的选择：
      - 节制，缩小依赖范围和向稳定方向依赖 
      - 避重趋轻、避繁逐简、以简驭繁、避虚就实 
      - 可替代性
   1. 主框架的选择 :
      - 架构上的优势为重
      - 没有不二法则
      - 拥抱未来
      - 经验价值高


  -----

    如何做选择呢？

    1. 首先符合妥适性原则：一切从实际需求出发，了解产品使用环境对实现的要求，避免过度实现。
    参考Yagni(雅格尼，You aren't gonna need it)法则：你想象可能会有的需求80%都不会发生。

    2. 选择库的原则：
      2-1. 时首先是节制，决定是否引入一个框架或库的时候，想想奥卡姆剃刀法则。“如无必要，勿增实体”

      2-2. 如果决定要用一个库时，参考奥卡姆剃刀所述的四原则:
        1. 避重趋轻：是轻量的，且功能单一的，一次只做好一件事
        2. 避繁逐简：接囗简洁，没有过多的概念
        3. 以简驭繁：通过简单组合，可以解决复杂的问题。换句话说，引入一个库，不是为了解决一个问题而是一类问题
        4. 避虚就实：一是针对问题的实质、能切实有效解决问题，二是避免引入过多无形的机制解决一个问题带来更多新问题。

      2-3. 可替代原则。引入一个库原本是为了简化实现，但是依赖太多库就会出现过多的代码冗余，依赖关系复杂，经常会发生版本冲突的问题。还会发生抽象渗透的问题，也就是当某个依赖的库出现bug时，难于发现和解决。在引用和组织代码的时候，可替换性是指当某个库有问题时可以方便替换。
    比如可以用到SOLID的依赖反转原则解藕，高层不直接依赖底层，而是共同依赖一个抽象层。 举个例子，网络请求很常见，我会写一个空壳，对外接囗是一致的，具体实现有些时候是原生写的，有些时候会用像superagent实现。这样就具有可替代性了。

    3. 主框架的选择，需要慎重，后期替换成本高。4点想法。
      3-1. 没有不二法则。没有什么是独一无二的选择。我不想比较React和Vue哪个更好，哪个更值得用。李小龙在他的《生活的艺术家》一书中说“刻意迷恋某一技术是一种病态，不管该技术是多么的有价值。”他有句名言“以无法为有法，以无限为有限”。意思是，当你会了一种招式后总想用它，这是错误的。要忘掉招式，根据眼前的局面，自由自主运用你掌握的技术，这才是高手的境界。前提是你要掌握各种“招式。

      3-2. 向前看，顺应趋势。因果律说“若能确切的了解现在，就能准确的预见未来”，虽然不可能完全了解现在，但了解的程度决定了你的洞察力

      3-3. 当多个选项都能满足需求时。考虑学习和使用某一个框架的经验，是否具有长效价值，是否可以转移到其它领域上。这也符合第2点，技术永远是向前发展的，符合这个发展路径的经验就具有长效价值。

      3-4. 主框架的首要选择标准，首要并非是体量、性能，这些可以优化，也不是学习成本、文档质量，这些不是太大的障碍。主要是看，它在模式设计上体现的优势、是否针对开发痛点、是否真正能以简驭繁、设计上的规约是否能带来秩序

  -----

  </template>


<template layout="bullets" type="text/x-markdown">
   ## 选择的原则 (新手版)

   1. 妥适性原则
   1. 库的选择，尽量同时满足以下条件：
      1. 单一性
      1. 普便性
      1. 轻量型
      1. 依赖少
   1. 主框架的选择：做足调研和实践，多和老司机交流
   1. Code Review 十分必要

--------

  1. 新手面临的现实问题就是搞定眼前的项目。

  2. 妥适性原则依然有效 还没有把握写好一个组件，需要依赖开源库实现功能。
  2-1. 不要选大而全，要选单一职责，一个库只做一件事
  2-2. 被广泛使用的。比如npm下载量大的
  2-3. 可以理解为越小越好。不要直接安装，看一眼源码再用
  2-4. 最好不再有其它依赖，或者依赖范围越少越好

  3. 主框架选择按照前面的原则，调研，并且提前有所实践

  4. CodeReview很重要，多和老司机交流

</template>


  <template layout="title"
  class="slide-shang"
  backface="./pics/b1.jpg"
  type="text/x-markdown">

  ## 软件熵

  ------

    警惕软件熵的问题。
    软件熵是用来说明软件在经过不断修改后，无序程度随之不断升高。
    过度引入各种库和依赖笨重的框架，会导致代码的无序程度恶化。

    前期: 本着前面所说的最简和可替代原则选择库。
    后期: 可以通过一些包分析工具，监控项目的依赖是否过重。经常性的做一些小规模重构。

  </template>

  <template layout="bullets" class="slide-sample" type="text/x-markdown">
  ## 35.4% vs. 64.6%

  ![](./pics/b2.jpg)

  -------

    开源库的选择：

    - 扩展语言能力（像immutable.js）
    - 基础功能性的（像Lodash)
    - 解决兼容问题的（像core.js、各种polyfill）
    - 少量成熟组件（像iscroll、moment）

    自有代码 324.3k
    开源项目代码 135.7k
    通用的开源项目代码 454k
    共 914k

    （source-map-explorer --html dist/js/note_editor.js > tree.html）

  </template>

  <template
  backface="./pics/b3.jpg"
  layout="title-movie" type="text/x-markdown">
  ------

     做一个项目，就像拍一部电影。选角色不是越大牌越好、越漂亮越好，一些都要符合剧本中的人物设定。
     
  </template>

  <template class="slide-end" layout="title" type="text/x-markdown">
  ## 谢谢!

  ------

    这就是我的一些想法。谢谢！

  </template>

  <script src="./dist/index.js"></script>
  <script>
  var talkie = Talkie({ wide: false, control: false });
  document.addEventListener('DOMContentLoaded', function() {
    talkie.changed.subscribe(function(current) {
      console.clear();
      console.info(talkie.notes[current.getAttribute('data-page')]);
    });
  });
</script>
</body>
</html>
